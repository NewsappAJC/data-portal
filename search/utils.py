# Stdlib imports
import os

# Third-party imports
from sqlalchemy import create_engine

# Constants
DATA_WAREHOUSE_URL = os.environ.get('DATA_WAREHOUSE_URL')
TMP_PATH = os.path.join('/tmp', 'ajc-import-searchfile.csv')
BUCKET_NAME = os.environ.get('S3_BUCKET')

class SearchManager(object):
    """
    This module handles generating search queries for all the tables in the
    database, filtering out all columns except those with a data_type specified
    by the user. It can also execute and return the results of raw SQL queries.
    """
    def simple_query(self, sql_query):
        """
        This method executes a SQL query and returns the result

        Arguments:
            sql_query (string): A raw SQL query

        Returns:
            search_result (string[][]): An array of arrays with the results of
            the query
        """
        connection = self.connect_to_db()
        search_result = connection.execute(sql_query).fetchall()
        connection.close

        return search_result


    def table_search(self, query, table, search_columns, preview=None):
        """
        This method performs a search on a subset of columns within a given
        table, and returns matching rows.

        Arguments:
            query (string): The search term
            table (string): The name of a table to search
            search_columns (string[]): An array containing the names of columns
            to be searched
            preview (int): If None, the method will return all matching rows.
            Otherwise, it will return the number of rows passed to this argument

        Returns:
            A two-tuple with the search SQL query generated by the function, and
            the resulting rows as an array of string[] arrays.
        """

        # Uncomment the lines below if you want to treat spaces as logical ANDs
        # r = re.compile(r'(^.)')
        # query = re.sub(r'[^\w\s]', '', query) # Strip out all non-alphanumeric characters
        # query = re.sub(r, '+' + r.match(query).group(1), query)
        # query = re.sub(r'\s', ' +', query) # MySQL treats + as logical AND

        sql_query = '''
            SELECT * FROM imports.{table}
            WHERE MATCH({search_columns})
            AGAINST('{query}' IN BOOLEAN MODE)
            '''.format(table=table, search_columns=search_columns, query=query)

        if preview:
            sql_query+='LIMIT {}'.format(str(preview))

        connection = self.connect_to_db()
        search_result = connection.execute(sql_query).fetchall()
        connection.close()

        if len(search_result) > 0:
            result = { 'table' : table,
                       'search_columns' : search_columns}
            result['preview']={}
            result['preview']['headers'] = search_result[0].keys()

            values = []
            for row in search_result:
                values.append(row.values())

            result['preview']['data'] = values

            if len(values) < 50:
                result['count'] = len(values)
            else:
                result['count'] = 'more than 50'

            return (sql_query, result)

        else:
            return None


    def warehouse_search(self, query, filter):
        """
        This method performs a search of columns within the Django DB and returns
        information about which tables contain columns matching the given datatype,
        and returns an array with rows matching the query

        Arguments:
            query (string): The term being searched for
            filter (string): The data_type the user is interested in (eg address)

        Returns:
            An array of string[] arrays with the specified number of rows
            matching the query.
        """
        if len(query)>0:
            connection = self.connect_to_db()
            filter = filter or ['name'] # Default to searching by name
            data_type = '("{}")'.format(('","').join(filter))

            #SQL statement below pulls unique database-table-columns combos
            #to feed into a search
            fquery = '''SELECT t.table, t.id,
                CONCAT('`',GROUP_CONCAT(c.column SEPARATOR '`,`'),'`') AS search_columns
                FROM data_import_tool.upload_table t
                JOIN data_import_tool.upload_column c
                ON t.id=c.table_id
                WHERE SUBSTRING_INDEX(c.information_type,"_",-1) IN {}
                GROUP BY 1'''.format(data_type)

            tables_to_search = connection.execute(fquery).fetchall()
            connection.close()

            results = []
            for table in tables_to_search:
                params = {
                    'query': query,
                    'table': table['table'],
                    'search_columns': table['search_columns'],
                    'preview': 5
                }
                throwaway, result = self.table_search(**params)

                if result:
                    result['id'] = int(table['id'])
                    results.append(result)

            return results

    def connect_to_db(self):
        """
        This method connects to the MySQL database and returns a sqlAlchemy
        connection object
        """
        engine = create_engine(DATA_WAREHOUSE_URL)
        return engine.connect()

